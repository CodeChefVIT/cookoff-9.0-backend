// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: testcases.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTestCase = `-- name: CreateTestCase :exec
INSERT INTO testcases (
    id, 
    expected_output, 
    memory, 
    input, 
    hidden, 
    question_id, 
    runtime
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreateTestCaseParams struct {
	ID             uuid.UUID
	ExpectedOutput string
	Memory         string
	Input          string
	Hidden         bool
	QuestionID     uuid.UUID
	Runtime        pgtype.Numeric
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) error {
	_, err := q.db.Exec(ctx, createTestCase,
		arg.ID,
		arg.ExpectedOutput,
		arg.Memory,
		arg.Input,
		arg.Hidden,
		arg.QuestionID,
		arg.Runtime,
	)
	return err
}

const deleteTestCase = `-- name: DeleteTestCase :exec
DELETE FROM testcases
WHERE id = $1
`

func (q *Queries) DeleteTestCase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTestCase, id)
	return err
}

const getAllTestCases = `-- name: GetAllTestCases :many
SELECT 
    id, expected_output, memory, input, hidden, runtime, question_id
FROM testcases
ORDER BY id ASC
`

func (q *Queries) GetAllTestCases(ctx context.Context) ([]Testcase, error) {
	rows, err := q.db.Query(ctx, getAllTestCases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Testcase
	for rows.Next() {
		var i Testcase
		if err := rows.Scan(
			&i.ID,
			&i.ExpectedOutput,
			&i.Memory,
			&i.Input,
			&i.Hidden,
			&i.Runtime,
			&i.QuestionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCase = `-- name: GetTestCase :one
SELECT 
    id, 
    expected_output, 
    memory, 
    input, 
    hidden, 
    question_id, 
    runtime
FROM testcases
WHERE id = $1
`

type GetTestCaseRow struct {
	ID             uuid.UUID
	ExpectedOutput string
	Memory         string
	Input          string
	Hidden         bool
	QuestionID     uuid.UUID
	Runtime        pgtype.Numeric
}

func (q *Queries) GetTestCase(ctx context.Context, id uuid.UUID) (GetTestCaseRow, error) {
	row := q.db.QueryRow(ctx, getTestCase, id)
	var i GetTestCaseRow
	err := row.Scan(
		&i.ID,
		&i.ExpectedOutput,
		&i.Memory,
		&i.Input,
		&i.Hidden,
		&i.QuestionID,
		&i.Runtime,
	)
	return i, err
}

const getTestCasesByQuestion = `-- name: GetTestCasesByQuestion :many
SELECT 
    id, 
    expected_output, 
    memory, 
    input, 
    hidden, 
    question_id, 
    runtime
FROM testcases
WHERE question_id = $1
`

type GetTestCasesByQuestionRow struct {
	ID             uuid.UUID
	ExpectedOutput string
	Memory         string
	Input          string
	Hidden         bool
	QuestionID     uuid.UUID
	Runtime        pgtype.Numeric
}

func (q *Queries) GetTestCasesByQuestion(ctx context.Context, questionID uuid.UUID) ([]GetTestCasesByQuestionRow, error) {
	rows, err := q.db.Query(ctx, getTestCasesByQuestion, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCasesByQuestionRow
	for rows.Next() {
		var i GetTestCasesByQuestionRow
		if err := rows.Scan(
			&i.ID,
			&i.ExpectedOutput,
			&i.Memory,
			&i.Input,
			&i.Hidden,
			&i.QuestionID,
			&i.Runtime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTestCase = `-- name: UpdateTestCase :exec
UPDATE testcases
SET 
    expected_output = $1,
    memory = $2,
    input = $3,
    hidden = $4,
    runtime = $5
WHERE id = $6
`

type UpdateTestCaseParams struct {
	ExpectedOutput string
	Memory         string
	Input          string
	Hidden         bool
	Runtime        pgtype.Numeric
	ID             uuid.UUID
}

func (q *Queries) UpdateTestCase(ctx context.Context, arg UpdateTestCaseParams) error {
	_, err := q.db.Exec(ctx, updateTestCase,
		arg.ExpectedOutput,
		arg.Memory,
		arg.Input,
		arg.Hidden,
		arg.Runtime,
		arg.ID,
	)
	return err
}
